# TBNF Grammar

TODO: make it so that the rule name "start" is the default start rule, not simply whatever rule comes first.
> start = ("" -> top)* $


TBNF is a language for specifying a variant of parser expression grammars.
Successful output from a TBNF grammar is a t-expression containing, in-order,
  every character of the original input.
TODO: describe what's different about tbnf vs peg.

## Large-Scale Structure

TBNF grammars are defined with a syntax similar to ABNF/ABNF.
The first notable difference however, is that TBNF is written in a literate coding style.
This allows for documentation of a grammar to be placed directly alongside the grammar itself.
In fact, you are reading a TBNF grammar _right now_.
Compare this to regular expression syntax, which focuses on the technical details, but which is notoriously write-only code.

In bird-style literate programming,
  all the lines of code are prefixed by a "bird foot",
  and all other lines are automatically considered documentation.
I personally recommend using Markdown syntax for documentation sections.
The name comes from the apparent resemblance of the greater-than sign
  to the footprint of a bird.

Here is the corresponding code that implements detecting bird feet and documentation lines.
Exactly how this syntax works will be explained later.
For now, the syntax should resemble familiar grammar definitions enough so that
  you won't have much issue reading it.
Note however, that identifiers followed by a colon indicate a "constructor",
  which will appear in the final output,
  wrapping the match of the grammar to the right of the colon.

> birdFoot = bird-foot: '>' ' '
> doc.line = doc:
>   / [^ >'\n' ]   # one character on the line that is not `>`
>     [^ '\n'  ]*  # any other characters on the line
>   /
>
> Doc = (doc.line nl? | nl)+

Beyond documentation, TBNF grammars consist of definitions (the `Def` rule).
These definitions are interspersed between documentation.
We can see that definitions begin at the start of a line, and there may be linear whitespace (`lws`) trailing the line.
Additionally, it is possible to have blank code lines, called here "vertical whitespace" `vws`.
Before moving on to definitions, I'll describe what is allowed for both linear and vertical whitespace.

> top
>   = Doc
>   | birdFoot Def lws* (nl | $)
>   | vws
>
> nl = nl: '\n'

Linear whitespace includes both space characters and inline comments.
Comments are preceded by a hash and continue to the end of the line.

> space = space: /' '+/
> comment = comment: '#' /[^'\n']*/

Additionally, if a code line is indented (in absolute terms), then it is effectively part of the previous line.
Blank code lines also do not contribute, so we also need to account for blank lines which consist _only_ of a greater-than symbol: thus, we introduce "improper" bird feet.
Note that these are wrapped in the same constructor as plain bird feet (including a space after the greater-than).
The same constructor may be used as many times in as many places as one likes.

> birdFoot.improper = bird-foot: '>' '\n'

With those preliminaries dealt with, we can easily read the definition of linear whitespace (lws).
Spaces, comments, and indented lines following blank code lines.
In this grammar we will generally use `lws*` and `lws+` because whitespace is sometimes optional and sometimes required.
TODO: Note that documentation is not allowed to come in the middle of a definition (I'm not sure that's a good thing to allow).

> lws = space
>     | comment
>     | nl birdFoot.improper* birdFoot lws

Vertical whitespace, on the other hand, consists of lines that contain at most linear whitespace.

> vws = birdFoot space* comment? nl
>     | birdFoot.improper


# TODO Here there Be Dragons



## Whitespace, Comments, & Documentation

Documentation is just any sequence of lines that do not begin with a `>`.
This will not generate empty documentation, but it does preserve empty lines.


Tokens are often separated by linear whitespace.
Do do so, we need not only skip over space characters (not tab),
  but also skip comments,
  and go into the next line as long as it is indented.
This implements a logical notion of whitespace, not merely graphical.


Additionally, we will need to skip _vertical_ whitespace.
This includes lines that are empty (except for a bird foot),
  and may include space characters and/or a comment.
As with linear whitespace, this skips _logically_ blank lines
  rather than merely graphically blank lines.


## Definitions

There are three sorts of definitions in a grammar.
One is a definition of the start rule,
  another to define the grammatical rules,
  and finally one to define character classes.

> Def = Def.Start | Def.Class | Def.Rule

> Def.Start = def-start: "@start" lws+ '=' lws+ Name.rule

TODO global rules are upcase, local rules and captures are locase

> Def.Rule = def-rule: Def.Rule.lhs lws+ '=' lws+ Rule<Rule.Flat>
> Def.Rule.lhs = rule-parametric:
>                 Name.rule enclose.angles<sep.comma<Name.param>>
>              | Name.rule

> Def.Class = def-class: enclose.colon<Name.class> lws+ '=' lws+ Class

## Rule Operators

> Rule<f>
>   = rule-alt: Rule.Term<f> (lws+ '|' -> lws+ Rule.Term<f>)+
>   | Rule.Term<f>
> Rule.Term<f>
>   = rule-ctor: Name.ctor colon Rule.Seq<f>
>   | Rule.Seq<f>
> Rule.Seq<f>
>   = rule-seq: Rule.Factor<f> (lws+ -> Rule.Factor<f>)+
>   | Rule.Factor<f>
> Rule.Factor<f>
>   = rule-rep: Rule.Rep.commit<f> Rule.Rep.amount
>   | Rule.Base<f>
> Rule.Rep.amount
>   = [*+?]
>   | rep-custom: enclose.braces<num.nat? comma num.nat?>
>   | rep-custom: enclose.braces<num.nat>
> Rule.Rep.commit<f>
>   = rule-commit: enclose.parens<Rule.Seq.allowFlat lws+ "->" lws+ Rule.Seq.allowFlat>
>   | Rule.Base<f>
> Rule.Base<f>
>   = rule-group: enclose.parens<Rule.allowFlat>
>   | rule-flat: f
>   | Rule.prim
> Rule.Flat = enclose<'/', Rule.disallowFlat, '/'>

> Rule.allowFlat = Rule<Rule.Flat>
> Rule.Seq.allowFlat = Rule.Seq<Rule.Flat>
> Rule.disallowFlat = Rule<$> # TODO use 0:"flat rule inside flat"

## Primitive Rules

> Rule.prim
>   = rule-call: Name.rule enclose.angles<sep.comma<Rule<Rule.Flat>>>?
>   | rule-char: '\'' char.sq '\''
>   | rule-string: '\"' chars.dq* '\"'
>   | rule-sat: ("[^" | '[') Rule.satisfy.part* ']'
>   | rule-end: '$'
>   | rule-void: '0' lws* ':' lws* '\"' chars.dq+ '\"'

> Rule.satisfy.part
>   = sat-range: '\'' char.sq '\'' ".." '\'' char.sq '\''
>   | sat-char: '\'' char.sq '\''
>   | sat-var: enclose.colon<Name.class>
>   | / [:char.brack:]+ /
>   | lws

## Classes

> Class = Class.term (lws+ Class.operator -> lws+ Class.term)*
>
> Class.operator = '|' | '-'
> Class.term
>   = class-var: enclose.colon<Name.class>
>   | class-range: '\'' char.sq '\'' ".." '\'' char.sq '\''
>   | class-char: '\'' char.sq '\''
>   | class-set: '\"' chars.dq* '\"'

## String and Character Literals

> char.sq
>   = [:char.sq:]
>   | char.escape
> :char.sq: = ' '..'~' - "\'\\"
>
> chars.dq
>   = /[:char.dq:]+/
>   | char.escape
> :char.dq: = ' '..'~' - "\"\\"
>
> :char.brack: = :ascii.print: - " []\'\"-:\\"

> char.escape
>   = char-escape: / '\\' [:char.escape.c:] /
>   | char-escape: "\\x" /[:digit.hex:]{2}/
>   | char-escape: "\\u" /[:digit.hex:]{4}/
>   | char-escape: "\\U"
>                     / '0' [:digit.hex:]{5}
>                     | "10" [:digit.hex:]{4}
>                     /
>   | char-escape: '\\' [:char.escape.passthru:]
> :char.escape.c: = "0abefnrtv"
> :char.escape.passthru: = :ascii.print: - :char.escape.c: - "xuU"

## Names

> Name.rule = / sep.dot<[:ascii.alpha:] [:ascii.alpha-num:]*> /
>
> Name.param = / [:ascii.alpha:] [:ascii.alpha-num:]* /

TODO: should this really by separated by dash? seems incongruent
> Name.ctor = / sep.dash<[:ascii.alpha:] [:ascii.alpha-num:]*> /

> Name.class = / sep.dot<[:ascii.alpha:] [:ascii.alpha-num:'\-']*> /

## General Combinators

> enclose<o,i,c> = o lws* i lws* c
>
> enclose.parens<i> = enclose<'(',i,')'>
> enclose.braces<i> = enclose<'{',i,'}'>
> enclose.angles<i> = enclose<'<',i,'>'>
> enclose.colon<i> = enclose<':',i,':'>

> comma = lws* ',' lws*
> colon = lws* ':' lws+

> sep.by<e,s> = e (s -> e)*
>
> sep.comma<e> = sep.by<e,comma>
> sep.dot<e> = sep.by<e,'.'>
> sep.dash<e> = sep.by<e,'-'>

## Basics

> :ascii.print: = ' '..'~'

> :digit: = '0'..'9'
> :digit.hex: = :digit: | 'a'..'f' | 'A'..'F'

> :ascii.alpha: = :ascii.alpha.lo: | :ascii.alpha.hi:
> :ascii.alpha.lo: = 'a'..'z'
> :ascii.alpha.hi: = 'A'..'Z'
> :ascii.alpha-num: = :ascii.alpha: | :digit:

> num.nat = / [:digit:] [:digit:]* /
